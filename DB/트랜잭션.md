## Transaction


### 1. 트랜잭션(Transaction)이란?
> All or Nothing

트랜잭션은 **작업의 완전성**을 보장해주는 것이다. 즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다.   
사용자의 입장에서는 **작업의 논리적 단위**로 이해를 할 수 있고 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.



### 2. 트랜잭션 지원 여부

보통 RDBMS는 기본으로 지원하는 경우가 많다.(RDBMS의 전유물이라고 할 수 있음)   
MongoDB를 제외한 대부분의 NoSQL에서는 트랜잭션을 지원하지 않는다.

#### 2-1. MySQL의 트랜잭션

> MySQL = MySQL 클라이언트 + MySQL 서버(3306 포트로 통신)   
> MySQL 서버 = MySQL 엔진 + 스토리지 엔진(Storage Engine)

(그냥 엔진은 통상적으로 스토리지 엔진을 말한다.)

**Storage Engine**에 따라 **트랜잭션 지원 여부**가 달라진다.   
MySQL 엔진에 여러 개의 스토리지 엔진을 선택/추가하여 사용 가능한, Pluggable(교체가능) 구조이다.

> mysql> show engines; (으로 확인 가능)

MyISAM: 가장 오래된 엔진, 트랜잭션 없음/외래키 지원 X, 테이블락   
InnoDB: 트랜잭션지원/외래키지원, 레코드락, MVCC 지원   
MyISAM -(대체)→ InnoDB   



### 3. 트랜잭션과 Lock
    
잠금(Lock)은 동시성을 제어하기 위한 기능이고,   
트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다.

- 잠금은 여러 커넥션에서 동시에 동일한 자원(레코드나 테이블)을 요청하는 경우, \
  순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 말한다.   

- 트랜잭션은 하나의 논리적인 작업셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것이다.



### 4. 트랜잭션의 특성
> 트랜잭션은 ACID 라는 4 가지 특성을 만족해야 한다.

- Atomicity, 원자성

    만약, 트랜잭션 중간에 어떠한 문제가 발생한다면, 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며, 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.
    
- Consistency, 일관성

    트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야한다.
    
- Isolation, 고립성
    
    각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.
    
- Durability, 지속성
    
    트랜잭션이 정상적으로 종료된 다음에는 영구적으로 DB에 작업의 결과가 저장되어야 한다.
    

### 5. 트랜잭션의 상태
![image](https://velog.velcdn.com/images/rik963/post/ecc22779-fff5-4999-9c86-5a09ced27132/image.png)

- Active
    
    트랜잭션 실행/동작 중
    
- Failed
    
    트랜잭션 실패
    
- Committed
    
    트랜잭션 (정상적으로) 완료.
    
- Aborted
    
    트랜잭션 취소 (트랜잭션 실행 이전 데이터로 돌아간 상태)
    
- Partially Committed
    
    Commit 요청이 들어오면 Partially Committed 상태가 됨.   
    
    이후 Commit이 문제 없이 수행 되면, Committed가 되고,   
    
    만약 오류가 발생하면, Failed 상태가 된다



### 6. 트랜잭션을 사용할 때 주의할 점
트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉, 트랜잭션의 범위를 최소화해야한다.   
일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다.   
그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있는 것이다.


