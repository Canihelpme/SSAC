# 변수와 메서드

## 선언 위치에 따른 변수의 종류

변수의 종류

- 클래스변수
- 인스턴스변수
- 지역변수

```java
class Variables
{
	// 클래스 영역
	int iv;          // 인스턴스 변수 - 인스턴스가 생성되었을 때 생성
	static int cv;   // 클래스 변수(static 변수, 공유 변수) - 클래스가 메모리에 올라갈 때 생성
	void method()
	{
		// 클래스 영역 이외의 영역(메서드, 생성자, 초기화 블럭 내부)
		// 여기는 메서드 영역
		int lv = 0;    // 지역 변수 - 변수 선언문이 수행되었을 때 생성
	}

}
```

멤버변수 중 static이 붙은 건 클래스 변수, 붙지 않은 건 인스턴스 변수

멤버 변수제외한 모든 것은 지역 변수

### 📌 인스턴스 변수

* 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스 변수로 선언

  → 인스턴스마다 독립적인 저장공간을 가짐

### 📌 클래스 변수

* 모든 인스턴스들의 공통된 값을 유지해야하는 속성의 경우, 클래스 변수로 선언

  → 모든 인스턴스가 공통된 저장공간(변수)를 공유

* 인스턴스를 생성하지 않고도 언제라도 바로 사용 가능함

* 클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때까지 유지

* public을 앞에 붙이면, 같은 프로그램 내 어디서나 접근 가능한 전역변수(global variable)의 성격

### 📌 지역변수

* 메서드 내에 선언되어 메서드 내에서만 사용 가능.

  for문 또는 while문의 블럭 내에 선언되었다면, 지역 변수가 선언 된 블럭 {} 내에서만 사용 가능.  


## 클래스변수와 인스턴스변수

트럼프 카드를 예로 들면,

```java
class Card {
  String kind;               //모양
  int number;                //카드 숫자
  static int width = 100;    //너비
  static int height = 250;   //높이
}
```

* 클래스 변수(static 변수)인 width, height는 Card 인스턴스 생성 없이도 사용 가능(공통된 값을 가짐)

* kind와 number는 생성된 인스턴스마다 각기 다른 값을 가짐

## 메서드

특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것.

메서드를 사용하는 이유

1. 높은 재사용성(reusability)
2. 중복된 코드의 제거 → 유지보수 용이
3. 프로그램의 구조화

## 메서드의 선언과 구현

메서드는 크게 선언부(header)와 구현부(body)로 이루어짐

### 📌 메서드 선언부

* 메서드 이름, 매개변수 선언, 반환타입으로 구성.

### 📌 메서드 구현부

* 메서드 호출 시 수행될 문장들과 ‘return 반환값;’ 으로 구성.

* 반환값은 반환 타입과 일치하거나 적어도 자동 형변환 가능해야함

* 매개변수는 여러 개일 수 있지만, 반환값은 최대 1개

## 메서드의 호출

* 메서드이름(괄호 안에는 인자) 로 호출.
* 메서드의 반환 값을 대입 연산자로 변수에 저장하는 것이 일반적이지만, 저장하지 않아도 문제되진 X

```
같은 클래스 내의 메서드끼리는 참조변수 사용하지 않고도 서로 호출 가능하지만,
static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없음
```

## return문

현재 실행중인 메서드를 종료하고 메서드를 호출한 자리로 되돌아감.

### 반환값(return value)

return문의 반환값으로 주로 변수가 오긴 하지만, 간단한 수식도 올 수 있음(→ 수식의 결과가 반환).

또는 (반환타입이 동일한)함수가 올 수도 있음.

### 매개변수의 유효성 검사

메서드의 구현부{}를 작성할 때, 매개변수의 값이 적절한 것인지 확인하는 절차가 필요.

적절하지 않은 값이 오면 값을 보정하거나,
return문을 이용하여 작업 중단하고 호출한 메서드로 되돌아가야함.

## JVM의 메모리 구조

응용프로그램이 실행 → 시스템으로부터 메모리 할당 받음  
→ JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리

### 3가지 주요 영역

1. 메서드 영역(method area)
    
    클래스가 사용되면, 해당 클래스의 클래스파일(*.class)을 읽고 분석하여 클래스 데이터를 이곳에 저장.  
    
    해당 클래스의 클래스 변수도 함께 생성.
    
2. 힙(heap)
    
    인스턴스가 생성되는 공간. 즉, 인스턴스 변수들이 생성되는 공간.
    
3. 호출 스택(call stack 또는 execution stack)
    
    호출된 메서드의 작업에 필요한 메모리 공간을 제공. 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용.
    
    - 메서드가 수행을 마치면 사용했던 메모리를 반환하고 스택에서 제거
    - 호출 스택의 맨 위에 있는 메서드가 현재 실행 중인 메서드
    - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드

## 기본형 매개변수와 참조형 매개변수

* 기본형 매개변수(primitive type): READ ONLY

* 참조형 매개변수(reference type): READ & WRITE

기본형 매개변수로 값을 넘기면, 값을 복사해오는 것이기 때문에 원본에는 영향 X  
참조형 매개변수로 값을 넘기면, 원본 값을 직접 변경 가능.

## 참조형 반환타입

반환타입이 ‘참조형’이라는 것은 메서드가 ‘객체의 주소’를 반환함을 의미함.

## 재귀호출(recursive call)

메서드 내부에서 메서드 자신을 다시 호출하는 것.

재귀 호출을 하는 메서드를 ‘재귀 메서드’라고 함.

- 호출된 메서드는 ‘값에 의한 호출(call by value)’을 통해 독립적인 작업 수행
- 매개변수 복사와 종료 후 복귀할 주소 저장 등이 추가로 필요
    - (반복문에 비해) 재귀호출의 수행시간이 더 오래 걸림
    - 그럼에도 쓰는건, ‘논리적 간결함’ 때문

```java
int factorial(int n) {
	if(n==1) return 1;
	
	return n * factorial(n-1);
}
```

```java
int factorial(int n) {
	int result = 1;
	while(n != 0)
		result *= n--;
	return result;
}
```

- 무한반복에 빠지지 않도록 조건문 필요
    - 메서드가 종료되지 않고 호출스택에 계속해서 쌓이면, 호출스택의 메모리 한계를 넘게 됨  
    → StackOverflowError 발생

## 클래스 메서드(static메서드)와 인스턴스 메서드

메서드 앞에 **static 붙으면**, 클래스 메서드. **없으면**, 인스턴스 메서드.

1. 클래스 설계 시, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static 붙이기
2. 클래스 변수(static 변수)는 인스턴스 생성 없이도 사용 가능
3. 클래스 메서드(static 메서드)는 인스턴스 변수 사용 불가
4. 메서드 내에서 인스턴스 변수를 사용하지 않으면, static 붙이는 것을 고려하자.
    -> static 메서드가 호출시간 더 짧음.

## 클래스 멤버와 인스턴스 멤버간의 참조와 호출

클래스 멤버가 존재하는 시점에 인스턴스 멤버는 존재하지 않을 수 있음을 주의!

- static 메서드 안에서는 인스턴스 메서드 호출 불가
- 인스턴스 멤버간의 호출에는 아무 문제 X
