# 1. 선점형 스케쥴링
## 1.Priority Scheduling

- 우선순위가 가장 높은 프로세스에게 CPU 를 할당하는 스케줄링이다. 우선순위란 정수로 표현하게 되고 작은 숫자가 우선순위가 높다.
- 선점형, 비선점형 방식 두가지 존재

##### 선점형 스케줄링(Preemptive) 방식
더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU 를 선점한다.

##### 비선점형 스케줄링(Non-Preemptive) 방식
더 높은 우선순위의 프로세스가 도착하면 Ready Queue 의 Head 에 넣는다.

#### 단점
- starvation
- 무기한 봉쇄(Indefinite blocking)
- 실행 준비는 되어있으나 CPU 를 사용못하는 프로세스를 CPU 가 무기한 대기하는 상태

#### 해결책
- aging
- 아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높이는 방식


## 3.SRTF(Shortest Remaining Time First)
- 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
- 현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time 을 가지는 새로운 프로세스가 도착하면 CPU 를 뺏긴다.

#### 단점
- 프로세스 생성 시 총 실행 시간 추정 작업 필요(새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수가 없다.)

- 잦은 선점으로 문맥 교환/오버헤드가 증가함

- 실행 시간이 긴 프로세스들의 평균 응답 시간 길어짐


# 2. 비선점형 스케쥴링

## 1. FCFS(First Come First Served)

- 준비 큐에 먼저 도착한 프로세스가 먼저 CPU를 점유하는 방식이다.
- CPU를 할당받으면 CPU 버스트가 완료될 때까지 CPU를 반환하지 않으며, 할당되었던 CPU가 반환될 때만 스케줄링이 이루어진다.
#### 장점
- 자원의 효율성을 높임 (처리중인 프로세스에게 할당된 시간을 타 프로세스가 뺏지 않으므로 문맥 교환이 일어나지 않음, 오버헤드 발생x)
- 일괄 처리 시스템에 적합함 (일괄 처리 시스템 - 한꺼번에 모아서 처리하는 시스템. == 세탁기)
#### 단점
- 프로세서를 장시간 독점하는 경우 다른 프로세스들이 오래 기다려야 함 (평균 응답시간이 길어질 수 있음)
- 대화형 시스템에 부적합 (대화형 시스템 - 사용자와 시스템 간의 실시간 대화를 기반으로 하는 시스템. 카톡과 비슷함)
- 우선순위가 높은 프로세스를 빨리 처리하지 못할수도 있음

|프로세스|도착시간|버스트 시간(프로세스 처리 시간)
|---|---|------|
|P1| 0ms | 24ms |
|P2| 1ms | 3ms |
|P3| 2ms | 3ms |

위의 프로세스 처리 스케쥴링 표
|P1|P2|P3|
|------|---|---|
|24ms|3ms|3ms|

- 들어온 순서대로 프로세스를 처리하기에 도착시간 순으로 처리한다. P1 P2 P3의 대기시간은 각각 0ms, 23ms, 25ms 이므로 평균 대기시간은 16ms 이다.

## 2. SJF(Shortest - Job - First)

- 다른 프로세스가 먼저 도착했어도 CPU burst time 이 짧은 프로세스에게 선 할당
#### 장점
- 평균 대기 시간 최소화
- 시스템 내의 대기 프로세스 수 최소화
- 많은 프로세스들에게 바른 응답 시간 제공

#### 단점
- 무기한 연기 현상 발생 가능
- 프로세스 생성 시 총 실행 시간에 대한 정확한 계산 불가능 
#### *starvation
효율성을 추구하는게 가장 중요하지만 특정 프로세스가 지나치게 차별받으면 안되는 것이다. 이 스케줄링은 극단적으로 CPU 사용이 짧은 job 을 선호한다. 그래서 사용 시간이 긴 프로세스는 거의 영원히 CPU 를 할당받을 수 없다.

## 3.Round Robin
- 가장 현대적인 CPU 스케줄링
- 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 된다.
- 할당 시간이 지나면 프로세스는 선점당하고 ready queue 의 제일 뒤에 가서 다시 줄을 선다.
- RR은 CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
- RR이 가능한 이유는 프로세스의 context 를 save 할 수 있기 때문이다.

#### 장점
- Response time이 빨라진다.
- n 개의 프로세스가 ready queue 에 있고 할당시간이 q(time quantum)인 경우 각 프로세스는 q 단위로 CPU 시간의 1/n 을 얻는다. 즉, 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.
- 프로세스가 기다리는 시간이 CPU 를 사용할 만큼 증가한다.

#### 주의할 점 
- 설정한 time quantum이 너무 커지면 FCFS와 같아진다. 
- 또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch 로 overhead 가 발생한다. 
- 그렇기 때문에 적당한 time quantum을 설정하는 것이 중요하다.